"use client"

import type React from "react"
import { useState, useRef, useEffect, useCallback } from "react"

interface AnimationSettings {
  speed: number
  easing: string
}

interface AnimationState {
  isPlaying: boolean
  isPaused: boolean
  progress: number
  startTime: number
  pausedTime: number
}

interface ButtonData {
  id: string
  name: string
  component: React.FC<{ settings: AnimationSettings; animationState: AnimationState }>
}

export default function ButtonMicroInteractions() {
  const [settings, setSettings] = useState<AnimationSettings>({
    speed: 1,
    easing: "cubic-bezier(0.4, 0, 0.2, 1)",
  })

  const [animationStates, setAnimationStates] = useState<{ [key: string]: AnimationState }>({})
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)
  const [dropdownPosition, setDropdownPosition] = useState<"bottom" | "top">("bottom")
  const dropdownRef = useRef<HTMLDivElement>(null)
  const selectRef = useRef<HTMLDivElement>(null)
  const animationFrameRefs = useRef<{ [key: string]: number }>({})

  // Initialize animation states
  const initializeAnimationState = useCallback(
    (buttonId: string): AnimationState => ({
      isPlaying: false,
      isPaused: false,
      progress: 0,
      startTime: 0,
      pausedTime: 0,
    }),
    [],
  )

  // Get animation duration for each button type
  const getAnimationDuration = useCallback(
    (buttonId: string): number => {
      const baseDurations: { [key: string]: number } = {
        parallax: 2,
        gradient: 3,
        magnetic: 1.5,
        border: 2,
        neon: 2.5,
        ripple: 0.6,
        glitch: 0.3,
        morph: 0.4,
        particle: 0.8,
        flip: 0.6,
        wave: 1.5,
        circuit: 2,
      }
      const baseDuration = baseDurations[buttonId] || 2
      return baseDuration / settings.speed
    },
    [settings.speed],
  )

  // Animation control functions
  const playAnimation = useCallback(
    (buttonId: string) => {
      const currentState = animationStates[buttonId] || initializeAnimationState(buttonId)
      const duration = getAnimationDuration(buttonId)

      // Cancel any existing animation
      if (animationFrameRefs.current[buttonId]) {
        cancelAnimationFrame(animationFrameRefs.current[buttonId])
      }

      const startTime = currentState.isPaused ? Date.now() - currentState.pausedTime * 1000 : Date.now()
      let isAnimating = true

      setAnimationStates((prev) => ({
        ...prev,
        [buttonId]: {
          ...currentState,
          isPlaying: true,
          isPaused: false,
          startTime,
        },
      }))

      const animate = () => {
        if (!isAnimating) return

        const elapsed = (Date.now() - startTime) / 1000
        const progress = Math.min((elapsed / duration) * 100, 100)

        setAnimationStates((prev) => ({
          ...prev,
          [buttonId]: {
            ...prev[buttonId],
            progress,
          },
        }))

        if (progress < 100) {
          animationFrameRefs.current[buttonId] = requestAnimationFrame(animate)
        } else {
          // Animation completed
          isAnimating = false
          setAnimationStates((prev) => ({
            ...prev,
            [buttonId]: {
              ...prev[buttonId],
              isPlaying: false,
              progress: 100,
            },
          }))
        }
      }

      animationFrameRefs.current[buttonId] = requestAnimationFrame(animate)
    },
    [animationStates, getAnimationDuration, initializeAnimationState],
  )

  const pauseAnimation = useCallback(
    (buttonId: string) => {
      if (animationFrameRefs.current[buttonId]) {
        cancelAnimationFrame(animationFrameRefs.current[buttonId])
      }

      setAnimationStates((prev) => {
        const currentState = prev[buttonId] || initializeAnimationState(buttonId)
        return {
          ...prev,
          [buttonId]: {
            ...currentState,
            isPlaying: false,
            isPaused: true,
            pausedTime: (currentState.progress / 100) * getAnimationDuration(buttonId),
          },
        }
      })
    },
    [getAnimationDuration, initializeAnimationState],
  )

  const stopAnimation = useCallback(
    (buttonId: string) => {
      if (animationFrameRefs.current[buttonId]) {
        cancelAnimationFrame(animationFrameRefs.current[buttonId])
      }

      setAnimationStates((prev) => ({
        ...prev,
        [buttonId]: initializeAnimationState(buttonId),
      }))
    },
    [initializeAnimationState],
  )

  const scrubAnimation = useCallback(
    (buttonId: string, progress: number) => {
      if (animationFrameRefs.current[buttonId]) {
        cancelAnimationFrame(animationFrameRefs.current[buttonId])
      }

      setAnimationStates((prev) => ({
        ...prev,
        [buttonId]: {
          ...(prev[buttonId] || initializeAnimationState(buttonId)),
          progress,
          isPlaying: false,
          isPaused: true,
          pausedTime: (progress / 100) * getAnimationDuration(buttonId),
        },
      }))
    },
    [getAnimationDuration, initializeAnimationState],
  )

  // Calculate optimal dropdown position
  const calculateDropdownPosition = () => {
    if (!selectRef.current) return "bottom"

    const rect = selectRef.current.getBoundingClientRect()
    const viewportHeight = window.innerHeight
    const spaceBelow = viewportHeight - rect.bottom - 20
    const spaceAbove = rect.top - 20
    const dropdownHeight = 240

    if (spaceBelow < 100 && spaceAbove > dropdownHeight) {
      return "top"
    }
    return "bottom"
  }

  const toggleDropdown = () => {
    if (!isDropdownOpen) {
      const position = calculateDropdownPosition()
      setDropdownPosition(position)
    }
    setIsDropdownOpen(!isDropdownOpen)
  }

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [])

  // Cleanup animation frames on unmount
  useEffect(() => {
    return () => {
      Object.values(animationFrameRefs.current).forEach((frameId) => {
        if (frameId) cancelAnimationFrame(frameId)
      })
    }
  }, [])

  // Button Components with Animation State Control
  const ParallaxButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const [mousePos, setMousePos] = useState({ x: 0, y: 0 })
    const buttonRef = useRef<HTMLButtonElement>(null)

    // Calculate animation-driven position
    const animatedPos = {
      x:
        animationState.isPlaying || animationState.isPaused
          ? Math.sin((animationState.progress / 100) * Math.PI * 2) * 20
          : mousePos.x,
      y:
        animationState.isPlaying || animationState.isPaused
          ? Math.cos((animationState.progress / 100) * Math.PI * 2) * 10
          : mousePos.y,
    }

    const handleMouseMove = (e: React.MouseEvent) => {
      if (animationState.isPlaying || animationState.isPaused) return
      if (!buttonRef.current) return
      const rect = buttonRef.current.getBoundingClientRect()
      setMousePos({
        x: (e.clientX - rect.left - rect.width / 2) / 10,
        y: (e.clientY - rect.top - rect.height / 2) / 10,
      })
    }

    return (
      <button
        ref={buttonRef}
        onMouseMove={handleMouseMove}
        onMouseLeave={() => !animationState.isPlaying && !animationState.isPaused && setMousePos({ x: 0, y: 0 })}
        className="parallax-button"
        style={{
          transition: animationState.isPlaying ? "none" : `all ${0.3 / settings.speed}s ${settings.easing}`,
        }}
      >
        <span 
          className="parallax-bg"
          style={{
            transform: `translate(${animatedPos.x * 2}px, ${animatedPos.y * 2}px)`,
            transition: animationState.isPlaying ? "none" : `transform ${0.3 / settings.speed}s ${settings.easing}`,
          }}
        />
        <span 
          className="parallax-text"
          style={{
            transform: `translate(${animatedPos.x}px, ${animatedPos.y}px)`,
            transition: animationState.isPlaying ? "none" : `transform ${0.3 / settings.speed}s ${settings.easing}`,
          }}
        >
          Parallax
        </span>
      </button>
    )
  }

  const FlowingGradientButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const backgroundPosition =
      animationState.isPlaying || animationState.isPaused ? `${(animationState.progress / 100) * 200}% 50%` : "0% 50%"

    return (
    <button 
      className="gradient-button"
      style={{
          backgroundPosition,
          transition: animationState.isPlaying ? "none" : "background-position 0.3s ease",
      }}
    >
      <span>Flowing Gradient</span>
    </button>
    )
  }

  const MagneticButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const [position, setPosition] = useState({ x: 0, y: 0 })
    const buttonRef = useRef<HTMLButtonElement>(null)

    const animatedPosition = {
      x:
        animationState.isPlaying || animationState.isPaused
          ? Math.sin((animationState.progress / 100) * Math.PI * 4) * 15
          : position.x,
      y:
        animationState.isPlaying || animationState.isPaused
          ? Math.cos((animationState.progress / 100) * Math.PI * 3) * 8
          : position.y,
    }

    const handleMouseMove = (e: React.MouseEvent) => {
      if (animationState.isPlaying || animationState.isPaused) return
      if (!buttonRef.current) return
      const rect = buttonRef.current.getBoundingClientRect()
      const x = e.clientX - rect.left - rect.width / 2
      const y = e.clientY - rect.top - rect.height / 2
      setPosition({ x: x * 0.3, y: y * 0.3 })
    }

    return (
      <button
        ref={buttonRef}
        onMouseMove={handleMouseMove}
        onMouseLeave={() => !animationState.isPlaying && !animationState.isPaused && setPosition({ x: 0, y: 0 })}
        className="magnetic-button"
        style={{
          transform: `translate(${animatedPosition.x}px, ${animatedPosition.y}px)`,
          transition: animationState.isPlaying ? "none" : `transform ${0.2 / settings.speed}s ${settings.easing}`,
        }}
      >
        Magnetic
      </button>
    )
  }

  const AnimatedBorderButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const backgroundPosition =
      animationState.isPlaying || animationState.isPaused ? `${(animationState.progress / 100) * 300}% 50%` : "0% 50%"

    return (
      <button
        className="animated-border-button"
        style={
          {
            "--border-duration": `${2 / settings.speed}s`,
            "--background-position": backgroundPosition,
          } as React.CSSProperties
        }
      >
        animated border
    </button>
    )
  }

  const NeonGlowButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const glowIntensity =
      animationState.isPlaying || animationState.isPaused
        ? 0.5 + Math.sin((animationState.progress / 100) * Math.PI * 2) * 0.3
        : 0.5

    return (
    <button 
      className="neon-button"
      style={{
          boxShadow: `
            0 0 ${20 * glowIntensity}px rgba(0, 255, 255, ${0.5 * glowIntensity}),
            inset 0 0 ${20 * glowIntensity}px rgba(0, 255, 255, ${0.1 * glowIntensity})
          `,
          transition: animationState.isPlaying ? "none" : `all ${0.3 / settings.speed}s ${settings.easing}`,
      }}
    >
      <span>Neon Glow</span>
    </button>
    )
  }

  const RippleButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const [ripples, setRipples] = useState<Array<{ x: number; y: number; id: number; progress: number }>>([])
    const buttonRef = useRef<HTMLButtonElement>(null)

    // Create animated ripple when timeline starts playing
    useEffect(() => {
      if (animationState.isPlaying && animationState.progress < 5) {
        const id = Date.now()
        setRipples([{ x: 50, y: 50, id, progress: 0 }])
      }
    }, [animationState.isPlaying])

    // Update ripple progress based on animation state
    useEffect(() => {
      if (animationState.isPlaying || animationState.isPaused) {
        setRipples((prev) =>
          prev.map((ripple) => ({
            ...ripple,
            progress: animationState.progress,
          })),
        )
      } else if (!animationState.isPlaying && !animationState.isPaused && animationState.progress === 0) {
        setRipples([])
      }
    }, [animationState])

    const createRipple = (e: React.MouseEvent) => {
      if (animationState.isPlaying || animationState.isPaused) return
      if (!buttonRef.current) return
      const rect = buttonRef.current.getBoundingClientRect()
      const x = ((e.clientX - rect.left) / rect.width) * 100
      const y = ((e.clientY - rect.top) / rect.height) * 100
      const id = Date.now()
      const newRipple = { x, y, id, progress: 0 }
      setRipples([newRipple])

      // Auto-animate the ripple
      let progress = 0
      const animateRipple = () => {
        progress += 2
        if (progress <= 100) {
          setRipples([{ ...newRipple, progress }])
          requestAnimationFrame(animateRipple)
        } else {
          setRipples([])
        }
      }
      requestAnimationFrame(animateRipple)
    }

    return (
      <button ref={buttonRef} onClick={createRipple} className="ripple-button">
        <span>Ripple</span>
        {ripples.map((ripple) => (
          <span
            key={ripple.id}
            className="ripple"
            style={{
              left: `${ripple.x}%`,
              top: `${ripple.y}%`,
              width: `${ripple.progress * 2}px`,
              height: `${ripple.progress * 2}px`,
              opacity: Math.max(0, 1 - ripple.progress / 100),
            }}
          />
        ))}
      </button>
    )
  }

  const GlitchButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const isGlitching = animationState.isPlaying || animationState.isPaused

    return (
      <button
        className={`glitch-button ${isGlitching ? "glitching" : ""}`}
        style={
          {
            "--glitch-duration": `${0.3 / settings.speed}s`,
            "--glitch-intensity": animationState.progress / 100,
          } as React.CSSProperties
        }
      >
        <span data-text="Glitch">Glitch</span>
    </button>
    )
  }

  const MorphButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const morphProgress = animationState.isPlaying || animationState.isPaused ? animationState.progress / 100 : 0
    const borderRadius = 50 - morphProgress * 38 // From 50px to 12px
    const rotation = morphProgress * 360
    const scale = 1 + Math.sin(morphProgress * Math.PI) * 0.1

    return (
    <button 
      className="morph-button"
      style={{
          borderRadius: `${borderRadius}px`,
          transform: `scale(${scale}) rotate(${rotation}deg)`,
          transition: animationState.isPlaying ? "none" : `all ${0.4 / settings.speed}s ${settings.easing}`,
      }}
    >
      <span>Morph</span>
    </button>
    )
  }

  const ParticleButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const [particles, setParticles] = useState<Array<{ id: number; x: number; y: number; progress: number }>>([])

    // Create particles when animation starts
    useEffect(() => {
      if (animationState.isPlaying && animationState.progress < 5) {
        const newParticles = Array.from({ length: 12 }, (_, i) => ({
          id: Date.now() + i,
          x: (Math.random() - 0.5) * 100,
          y: (Math.random() - 0.5) * 100,
          progress: 0,
        }))
        setParticles(newParticles)
      }
    }, [animationState.isPlaying])

    // Update particle progress
    useEffect(() => {
      if (animationState.isPlaying || animationState.isPaused) {
        setParticles((prev) =>
          prev.map((particle) => ({
            ...particle,
            progress: animationState.progress,
          })),
        )
      } else if (!animationState.isPlaying && !animationState.isPaused && animationState.progress === 0) {
        setParticles([])
      }
    }, [animationState])

    const createParticles = (e: React.MouseEvent<HTMLButtonElement>) => {
      if (animationState.isPlaying || animationState.isPaused) return
      const newParticles = Array.from({ length: 12 }, (_, i) => ({
        id: Date.now() + i,
        x: (Math.random() - 0.5) * 100,
        y: (Math.random() - 0.5) * 100,
        progress: 0,
      }))
      setParticles(newParticles)

      // Auto-animate particles
      let progress = 0
      const animateParticles = () => {
        progress += 1.5
        if (progress <= 100) {
          setParticles((prev) => prev.map((p) => ({ ...p, progress })))
          requestAnimationFrame(animateParticles)
        } else {
          setParticles([])
        }
      }
      requestAnimationFrame(animateParticles)
    }

    return (
      <button onClick={createParticles} className="particle-button">
        <span>Particles</span>
        <div className="particles">
          {particles.map((p) => (
            <span
              key={p.id}
              className="particle"
              style={{
                transform: `translate(${p.x * (p.progress / 100)}px, ${p.y * (p.progress / 100)}px) scale(${Math.max(0, 1 - p.progress / 100)})`,
                opacity: Math.max(0, 1 - p.progress / 100),
              }}
            />
          ))}
        </div>
      </button>
    )
  }

  const FlipButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const rotationY = animationState.isPlaying || animationState.isPaused ? (animationState.progress / 100) * 180 : 0

    return (
    <button 
      className="flip-button"
      style={{
          transform: `rotateY(${rotationY}deg)`,
          transition: animationState.isPlaying ? "none" : `transform ${0.6 / settings.speed}s ${settings.easing}`,
      }}
    >
      <span className="flip-front">3D Flip</span>
      <span className="flip-back">Flipped!</span>
    </button>
    )
  }

  const WaveButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const wavePosition =
      animationState.isPlaying || animationState.isPaused ? -100 + (animationState.progress / 100) * 300 : -100

    return (
    <button className="wave-button">
      <span>Wave</span>
      <div 
        className="wave"
        style={{
            left: `${wavePosition}%`,
            transition: animationState.isPlaying ? "none" : "left 0.3s ease",
        }}
      />
    </button>
    )
  }

  const CircuitButton: React.FC<{ settings: AnimationSettings; animationState: AnimationState }> = ({
    settings,
    animationState,
  }) => {
    const strokeDashoffset =
      animationState.isPlaying || animationState.isPaused ? 200 - (animationState.progress / 100) * 400 : 200

    return (
    <button className="circuit-button">
      <svg className="circuit-svg" viewBox="0 0 200 60">
        <path
          className="circuit-path"
          d="M10,30 L40,30 L50,20 L90,20 L100,30 L130,30 L140,40 L180,40"
          style={{
              strokeDashoffset,
              transition: animationState.isPlaying ? "none" : "stroke-dashoffset 0.3s ease",
          }}
        />
      </svg>
      <span>Circuit</span>
    </button>
    )
  }

  const buttons: ButtonData[] = [
    { id: "parallax", name: "Parallax Effect", component: ParallaxButton },
    { id: "gradient", name: "Flowing Gradient", component: FlowingGradientButton },
    { id: "magnetic", name: "Magnetic", component: MagneticButton },
    { id: "border", name: "Animated Border", component: AnimatedBorderButton },
    { id: "neon", name: "Neon Glow", component: NeonGlowButton },
    { id: "ripple", name: "Ripple", component: RippleButton },
    { id: "glitch", name: "Glitch", component: GlitchButton },
    { id: "morph", name: "Morph", component: MorphButton },
    { id: "particle", name: "Particles", component: ParticleButton },
    { id: "flip", name: "3D Flip", component: FlipButton },
    { id: "wave", name: "Wave", component: WaveButton },
    { id: "circuit", name: "Circuit", component: CircuitButton },
  ]

  const easingOptions = [
    { value: "linear", label: "Linear" },
    { value: "ease", label: "Ease" },
    { value: "ease-in", label: "Ease In" },
    { value: "ease-out", label: "Ease Out" },
    { value: "ease-in-out", label: "Ease In Out" },
    { value: "cubic-bezier(0.4, 0, 0.2, 1)", label: "Material" },
    { value: "cubic-bezier(0.68, -0.55, 0.265, 1.55)", label: "Elastic" },
  ]

  return (
    <div className="container fadeInUp">
      <style jsx global>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
        }

        body {
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: #0a0a0f;
          color: #ffffff;
          overflow-x: hidden;
          font-feature-settings: 'kern' 1, 'liga' 1, 'cv02' 1, 'cv03' 1, 'cv04' 1, 'cv11' 1;
          font-optical-sizing: auto;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        }

        .container {
          min-height: 100vh;
          padding: 1.5rem;
          background: 
            radial-gradient(ellipse at top, rgba(16, 16, 35, 0.8) 0%, transparent 60%),
            radial-gradient(ellipse at bottom right, rgba(30, 30, 60, 0.6) 0%, transparent 60%),
            linear-gradient(135deg, #0a0a0f 0%, #0f0f1a 50%, #1a1a2e 100%);
          position: relative;
          animation: fadeInUp 0.8s ease-out;
        }

        .container::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: 
            radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 40% 20%, rgba(119, 198, 255, 0.1) 0%, transparent 50%);
          pointer-events: none;
        }

        .header {
          text-align: center;
          margin-bottom: 5rem;
          position: relative;
          z-index: 1;
          padding: 2rem 0;
        }

        .header::after {
          content: '';
          position: absolute;
          bottom: -2rem;
          left: 50%;
          transform: translateX(-50%);
          width: 120px;
          height: 1px;
          background: linear-gradient(90deg, transparent, rgba(139, 95, 191, 0.6), transparent);
        }

        .stats-container {
          display: flex;
          justify-content: center;
          gap: 3rem;
          margin-top: 3rem;
          opacity: 0;
          animation: fadeInStats 1s ease-out 0.5s forwards;
        }

        @keyframes fadeInStats {
          from { opacity: 0; transform: translateY(20px); }
          to { opacity: 1; transform: translateY(0); }
        }

        .stat-item {
          text-align: center;
          position: relative;
        }

        .stat-item::before {
          content: '';
          position: absolute;
          top: -0.5rem;
          left: 50%;
          transform: translateX(-50%);
          width: 80px;
          height: 80px;
          background: radial-gradient(circle, rgba(139, 95, 191, 0.1) 0%, transparent 70%);
          border-radius: 50%;
          z-index: -1;
        }

        .stat-number {
          font-size: 2.5rem;
          font-weight: 700;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
          margin-bottom: 0.5rem;
          line-height: 1;
        }

        .stat-label {
          font-size: 0.875rem;
          color: #94a3b8;
          font-weight: 500;
          letter-spacing: 0.025em;
          text-transform: uppercase;
        }

        .title {
          font-size: clamp(2.5rem, 5vw, 4rem);
          font-weight: 700;
          background: linear-gradient(135deg, #8b5fbf 0%, #667eea 30%, #764ba2 70%, #a855f7 100%);
          background-size: 200% 100%;
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
          margin-bottom: 0.75rem;
          letter-spacing: -0.02em;
          line-height: 1.1;
          animation: gradient-shimmer 8s ease-in-out infinite;
        }

        @keyframes gradient-shimmer {
          0%, 100% { background-position: 0% 50%; }
          50% { background-position: 100% 50%; }
        }

        .subtitle {
          font-size: 1.25rem;
          color: #94a3b8;
          font-weight: 400;
          letter-spacing: 0.01em;
          opacity: 0.9;
          max-width: 600px;
          margin: 0 auto;
          line-height: 1.6;
        }

        .main-grid {
          display: grid;
          grid-template-columns: 320px 1fr;
          gap: 2.5rem;
          max-width: 1600px;
          margin: 0 auto;
          position: relative;
          z-index: 1;
          align-items: start;
        }

        .control-panel {
          background: 
            linear-gradient(145deg, rgba(26, 26, 46, 0.95) 0%, rgba(16, 16, 32, 0.9) 100%);
          backdrop-filter: blur(24px) saturate(180%);
          border-radius: 24px;
          padding: 2.5rem;
          border: 1px solid rgba(139, 95, 191, 0.2);
          box-shadow: 
            0 20px 40px rgba(0, 0, 0, 0.4),
            0 8px 16px rgba(0, 0, 0, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.15),
            inset 0 0 20px rgba(139, 95, 191, 0.05);
          height: fit-content;
          position: sticky;
          top: 1.5rem;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-panel:hover {
          transform: translateY(-2px);
          box-shadow: 
            0 24px 48px rgba(0, 0, 0, 0.5),
            0 12px 20px rgba(0, 0, 0, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.2),
            inset 0 0 24px rgba(139, 95, 191, 0.08);
          border-color: rgba(139, 95, 191, 0.3);
        }

        .control-title {
          font-size: 1.75rem;
          font-weight: 600;
          margin-bottom: 2.5rem;
          color: #f8fafc;
          letter-spacing: -0.01em;
          display: flex;
          align-items: center;
          gap: 0.75rem;
        }

        .control-title::before {
          content: '';
          display: inline-block;
          width: 2.2rem;
          height: 2.2rem;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border-radius: 12px;
          padding: 0.5rem;
          margin-right: 0.5rem;
          box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
          background-image: url('data:image/svg+xml;utf8,<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 3L18.09 11.26L27 12.27L20 18.14L22.18 27L16 22.77L9.82 27L12 18.14L5 12.27L13.91 11.26L16 3Z" stroke="%23fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg>');
          background-repeat: no-repeat;
          background-position: center;
          background-size: 1.4rem 1.4rem;
        }

        .control-group {
          margin-bottom: 2.5rem;
          position: relative;
        }

        .control-group::after {
          content: '';
          position: absolute;
          bottom: -1.25rem;
          left: 0;
          right: 0;
          height: 1px;
          background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.06), transparent);
        }

        .control-group:last-child::after {
          display: none;
        }

        .control-label {
          display: block;
          font-size: 1rem;
          color: #fff;
          margin-bottom: 0.5rem;
          font-weight: 600;
          letter-spacing: 0.03em;
          text-transform: uppercase;
          background: none;
          -webkit-background-clip: unset;
          -webkit-text-fill-color: unset;
          background-clip: unset;
          text-shadow: none;
        }

        .slider-container {
          display: flex;
          align-items: center;
          gap: 1rem;
          margin-bottom: 0.5rem;
        }

        .slider {
          flex: 1;
          height: 8px;
          background: linear-gradient(90deg, #667eea 0%, #a855f7 100%);
          border-radius: 4px;
          outline: none;
          -webkit-appearance: none;
          position: relative;
          cursor: pointer;
          box-shadow: 0 2px 12px 0 rgba(139,95,191,0.18);
        }

        .slider::-webkit-slider-thumb {
          -webkit-appearance: none;
          width: 24px;
          height: 24px;
          background: linear-gradient(135deg, #a855f7 0%, #667eea 100%);
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 4px 16px 0 rgba(139,95,191,0.25), 0 0 0 4px rgba(102,126,234,0.15);
          border: 2px solid #fff;
          transition: transform 0.2s cubic-bezier(0.4,0,0.2,1);
        }

        .slider::-webkit-slider-thumb:hover {
          transform: scale(1.12);
          box-shadow: 0 6px 20px 0 rgba(139,95,191,0.35), 0 0 0 6px rgba(102,126,234,0.18);
        }

        .slider::-moz-range-thumb {
          width: 24px;
          height: 24px;
          background: linear-gradient(135deg, #a855f7 0%, #667eea 100%);
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 4px 16px 0 rgba(139,95,191,0.25), 0 0 0 4px rgba(102,126,234,0.15);
          border: 2px solid #fff;
          transition: transform 0.2s cubic-bezier(0.4,0,0.2,1);
        }

        .slider::-moz-range-thumb:hover {
          transform: scale(1.12);
          box-shadow: 0 6px 20px 0 rgba(139,95,191,0.35), 0 0 0 6px rgba(102,126,234,0.18);
        }

        .slider::-ms-thumb {
          width: 24px;
          height: 24px;
          background: linear-gradient(135deg, #a855f7 0%, #667eea 100%);
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 4px 16px 0 rgba(139,95,191,0.25), 0 0 0 4px rgba(102,126,234,0.15);
          border: 2px solid #fff;
          transition: transform 0.2s cubic-bezier(0.4,0,0.2,1);
        }

        .slider-value {
          min-width: 48px;
          text-align: right;
          font-weight: 600;
          color: #fff;
          font-size: 1.1rem;
          letter-spacing: 0.02em;
          background: none;
          -webkit-background-clip: unset;
          -webkit-text-fill-color: unset;
          background-clip: unset;
          text-shadow: none;
        }

        .select {
          width: 100%;
          padding: 0.875rem 1rem;
          background: rgba(16, 16, 32, 0.8);
          border: 1px solid rgba(139, 95, 191, 0.3);
          border-radius: 12px;
          color: #f1f5f9;
          font-size: 0.9rem;
          font-weight: 500;
          outline: none;
          cursor: pointer;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          backdrop-filter: blur(8px);
          display: flex;
          align-items: center;
          justify-content: space-between;
          position: relative;
        }

        .select::after {
          content: "▼";
          font-size: 0.75rem;
          color: #94a3b8;
          transition: transform 0.3s ease;
        }

        .select.open::after {
          transform: rotate(180deg);
        }

        .select:hover {
          background: rgba(16, 16, 32, 0.9);
          border-color: rgba(139, 95, 191, 0.5);
          transform: translateY(-1px);
          box-shadow: 0 4px 12px rgba(139, 95, 191, 0.2);
        }

        .select:focus {
          border-color: #667eea;
          box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
          background: rgba(16, 16, 32, 0.95);
        }

        .select-container {
          position: relative;
          width: 100%;
        }

        .dropdown {
          position: absolute;
          left: 0;
          right: 0;
          z-index: 1000;
          background: rgba(16, 16, 32, 0.95);
          backdrop-filter: blur(16px) saturate(180%);
          border: 1px solid rgba(139, 95, 191, 0.4);
          border-radius: 8px;
          max-height: 200px;
          overflow-y: auto;
          box-shadow: 
            0 20px 40px rgba(0, 0, 0, 0.4),
            0 8px 16px rgba(0, 0, 0, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          animation: dropdownSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
          margin-top: 0.25rem;
        }

        .dropdown.position-bottom {
          top: 100%;
          margin-top: 0.5rem;
        }

        .dropdown.position-top {
          bottom: 100%;
          margin-bottom: 0.5rem;
        }

        .dropdown::-webkit-scrollbar {
          width: 6px;
        }

        .dropdown::-webkit-scrollbar-track {
          background: rgba(255, 255, 255, 0.05);
          border-radius: 3px;
        }

        .dropdown::-webkit-scrollbar-thumb {
          background: rgba(139, 95, 191, 0.6);
          border-radius: 3px;
          transition: background 0.3s ease;
        }

        .dropdown::-webkit-scrollbar-thumb:hover {
          background: rgba(139, 95, 191, 0.8);
        }

        .dropdown {
          scrollbar-width: thin;
          scrollbar-color: rgba(139, 95, 191, 0.6) rgba(255, 255, 255, 0.05);
        }

        @keyframes dropdownSlideIn {
          0% {
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }

        @keyframes dropdownSlideInTop {
          0% {
            opacity: 0;
            transform: translateY(10px) scale(0.95);
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }

        .dropdown.position-top {
          animation: dropdownSlideInTop 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .dropdown-item {
          padding: 0.65rem 1rem;
          color: #e2e8f0;
          font-size: 0.95rem;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
          position: relative;
          overflow: hidden;
          border-radius: 6px;
        }

        .dropdown-item:last-child {
          border-bottom: none;
          margin-bottom: 2px;
        }

        .dropdown-item::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(139, 95, 191, 0.1), transparent);
          transition: left 0.3s ease;
        }

        .dropdown-item:hover {
          background: rgba(139, 95, 191, 0.15);
          color: #f8fafc;
          transform: translateX(4px);
        }

        .dropdown-item:hover::before {
          left: 0;
        }

        .dropdown-item:active {
          transform: translateX(2px) scale(0.98);
        }

        .dropdown-item.selected {
          background: rgba(139, 95, 191, 0.2);
          color: #667eea;
          font-weight: 600;
        }

        .dropdown-item.selected::before {
          left: 0;
          background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.15), transparent);
        }

        .buttons-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
          gap: 2.5rem;
          padding: 1rem;
          position: relative;
        }

        .buttons-grid::before {
          content: '';
          position: absolute;
          top: -1rem;
          left: 0;
          right: 0;
          height: 1px;
          background: linear-gradient(90deg, transparent, rgba(139, 95, 191, 0.3), transparent);
        }

        .button-card {
          background: 
            linear-gradient(145deg, rgba(26, 26, 46, 0.7) 0%, rgba(16, 16, 32, 0.6) 100%);
          backdrop-filter: blur(16px) saturate(160%);
          border-radius: 20px;
          padding: 2.5rem;
          border: 1px solid rgba(255, 255, 255, 0.08);
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          position: relative;
          overflow: hidden;
          isolation: isolate;
          animation: slideInCard 0.6s ease-out backwards;
        }

        .button-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: radial-gradient(
            circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
            rgba(102, 126, 234, 0.1) 0%,
            transparent 50%
          );
          opacity: 0;
          transition: opacity 0.3s ease;
          pointer-events: none;
        }

        .button-card:hover::before {
          opacity: 1;
        }

        .button-card:hover {
          transform: translateY(-8px) scale(1.02);
          box-shadow: 
            0 20px 40px rgba(0, 0, 0, 0.4),
            0 8px 16px rgba(0, 0, 0, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.15),
            0 0 0 1px rgba(139, 95, 191, 0.2);
          border-color: rgba(139, 95, 191, 0.3);
          background: 
            linear-gradient(145deg, rgba(26, 26, 46, 0.8) 0%, rgba(16, 16, 32, 0.7) 100%);
        }

        .button-name {
          font-size: 1.125rem;
          font-weight: 600;
          color: #f1f5f9;
          margin-bottom: 2rem;
          letter-spacing: -0.01em;
          display: flex;
          align-items: center;
          gap: 0.75rem;
        }

        .button-name::before {
          content: '';
          width: 8px;
          height: 8px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border-radius: 50%;
          box-shadow: 0 0 12px rgba(102, 126, 234, 0.6);
          animation: pulse-dot 2s ease-in-out infinite;
          transition: all 0.3s ease;
        }

        .button-card:hover .button-name::before {
          width: 10px;
          height: 10px;
          box-shadow: 0 0 16px rgba(102, 126, 234, 0.8);
        }

        @keyframes pulse-dot {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.2); opacity: 0.8; }
        }

        .button-preview {
          height: 140px;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-bottom: 1.5rem;
          position: relative;
          background: 
            radial-gradient(circle at center, rgba(139, 95, 191, 0.03) 0%, transparent 70%);
          border-radius: 16px;
          border: 1px solid rgba(255, 255, 255, 0.04);
          transition: all 0.3s ease;
        }

        .button-preview:hover {
          background: 
            radial-gradient(circle at center, rgba(139, 95, 191, 0.05) 0%, transparent 70%);
          border-color: rgba(255, 255, 255, 0.06);
        }

        .timeline {
          background: 
            linear-gradient(145deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
          border-radius: 12px;
          position: relative;
          overflow: hidden;
          border: 1px solid rgba(255, 255, 255, 0.05);
          transition: all 0.3s ease;
          padding: 1rem;
        }

        .timeline:hover {
          background: 
            linear-gradient(145deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
          border-color: rgba(139, 95, 191, 0.2);
        }

        .timeline-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.75rem;
        }

        .timeline-label {
          font-size: 0.875rem;
          color: #94a3b8;
          font-weight: 500;
          letter-spacing: -0.01em;
        }

        .timeline-info {
          display: flex;
          gap: 1rem;
          font-size: 0.75rem;
          color: #64748b;
        }

        .timeline-controls {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 0.75rem;
        }

        .timeline-btn {
          background: rgba(139, 95, 191, 0.2);
          border: 1px solid rgba(139, 95, 191, 0.4);
          border-radius: 6px;
          color: #e2e8f0;
          padding: 0.375rem 0.75rem;
          font-size: 0.75rem;
          cursor: pointer;
          transition: all 0.2s ease;
          font-weight: 500;
        }

        .timeline-btn:hover {
          background: rgba(139, 95, 191, 0.3);
          border-color: rgba(139, 95, 191, 0.6);
          transform: translateY(-1px);
        }

        .timeline-btn:active {
          transform: translateY(0);
        }

        .timeline-btn.active {
          background: rgba(102, 126, 234, 0.3);
          border-color: rgba(102, 126, 234, 0.6);
          color: #f8fafc;
        }

        .timeline-track {
          height: 8px;
          background: rgba(255, 255, 255, 0.08);
          border-radius: 4px;
          position: relative;
          cursor: pointer;
          margin-bottom: 0.5rem;
        }

        .timeline-track:hover {
          background: rgba(255, 255, 255, 0.12);
        }

        .timeline-bar {
          height: 100%;
          background: linear-gradient(90deg, #667eea 0%, #764ba2 50%, #a855f7 100%);
          border-radius: 4px;
          box-shadow: 0 0 12px rgba(102, 126, 234, 0.4);
          position: relative;
          transition: width 0.1s ease;
        }

        .timeline-bar::after {
          content: '';
          position: absolute;
          right: -6px;
          top: 50%;
          transform: translateY(-50%);
          width: 12px;
          height: 12px;
          background: #667eea;
          border-radius: 50%;
          box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
          opacity: 0;
          transition: opacity 0.3s ease;
        }

        .timeline-track:hover .timeline-bar::after {
          opacity: 1;
        }

        .timeline-details {
          display: flex;
          justify-content: space-between;
          align-items: center;
          font-size: 0.75rem;
          color: #64748b;
        }

        .timeline-time {
          font-family: 'Monaco', 'Menlo', monospace;
          background: rgba(255, 255, 255, 0.05);
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
        }

        .timeline-phases {
          display: flex;
          gap: 0.25rem;
          margin-top: 0.5rem;
        }

        .timeline-phase {
          height: 3px;
          background: rgba(255, 255, 255, 0.1);
          border-radius: 1.5px;
          flex: 1;
          position: relative;
          overflow: hidden;
        }

        .timeline-phase.active {
          background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
          box-shadow: 0 0 6px rgba(102, 126, 234, 0.4);
        }

        .timeline-phase.completed {
          background: rgba(102, 126, 234, 0.6);
        }

        /* Button Styles */
        button {
          cursor: pointer;
          border: none;
          font-weight: 600;
          font-size: 1rem;
          padding: 1rem 2rem;
          border-radius: 12px;
          position: relative;
          overflow: hidden;
          color: #ffffff;
          outline: none;
          font-family: inherit;
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        button:focus-visible {
          outline: 2px solid rgba(102, 126, 234, 0.6);
          outline-offset: 2px;
        }

        /* Parallax Button */
        .parallax-button {
          background: transparent;
          border: 2px solid rgba(102, 126, 234, 0.5);
          position: relative;
          transform-style: preserve-3d;
          perspective: 1000px;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .parallax-bg {
          position: absolute;
          top: -2px;
          left: -2px;
          right: -2px;
          bottom: -2px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border-radius: 12px;
          opacity: 0;
          transition: opacity 0.3s ease;
          z-index: -1;
        }

        .parallax-button:hover .parallax-bg {
          opacity: 0.2;
        }

        .parallax-text {
          position: relative;
          z-index: 1;
        }

        /* Flowing Gradient Button */
        .gradient-button {
          background: linear-gradient(
            90deg,
            #667eea 0%,
            #764ba2 25%,
            #f093fb 50%,
            #764ba2 75%,
            #667eea 100%
          );
          background-size: 200% 100%;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .gradient-button:hover {
          transform: scale(1.05);
          box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
        }

        /* Magnetic Button */
        .magnetic-button {
          background: #1a1a2e;
          border: 2px solid #667eea;
          transition: all 0.3s ease;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .magnetic-button:hover {
          background: #667eea;
          box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
        }

        /* Neon Glow Button */
        .neon-button {
          background: transparent;
          border: 2px solid #00ffff;
          color: #00ffff;
          text-shadow: 0 0 10px #00ffff;
          box-shadow: 
            0 0 20px rgba(0, 255, 255, 0.5),
            inset 0 0 20px rgba(0, 255, 255, 0.1);
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .neon-button:hover {
          background: rgba(0, 255, 255, 0.1);
          box-shadow: 
            0 0 40px rgba(0, 255, 255, 0.8),
            inset 0 0 20px rgba(0, 255, 255, 0.2);
          transform: scale(1.05);
        }

        /* Ripple Button */
        .ripple-button {
          background: #667eea;
          position: relative;
          overflow: hidden;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .ripple {
          position: absolute;
          border-radius: 50%;
          background: rgba(255, 255, 255, 0.5);
          transform: translate(-50%, -50%);
          pointer-events: none;
        }

        /* Glitch Button */
        .glitch-button {
          background: #1a1a2e;
          border: 2px solid #ff0080;
          position: relative;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .glitch-button span {
          position: relative;
          display: block;
        }

        .glitch-button span::before,
        .glitch-button span::after {
          content: attr(data-text);
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0;
        }

        .glitch-button.glitching span::before {
          animation: glitch-1 0.3s infinite;
          color: #00ffff;
          opacity: 0.8;
        }

        .glitch-button.glitching span::after {
          animation: glitch-2 0.3s infinite;
          color: #ff0080;
          opacity: 0.8;
        }

        @keyframes glitch-1 {
          0% { transform: translate(0); }
          20% { transform: translate(-2px, 2px); }
          40% { transform: translate(-2px, -2px); }
          60% { transform: translate(2px, 2px); }
          80% { transform: translate(2px, -2px); }
          100% { transform: translate(0); }
        }

        @keyframes glitch-2 {
          0% { transform: translate(0); }
          20% { transform: translate(2px, -2px); }
          40% { transform: translate(2px, 2px); }
          60% { transform: translate(-2px, -2px); }
          80% { transform: translate(-2px, 2px); }
          100% { transform: translate(0); }
        }

        /* Morph Button */
        .morph-button {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          border-radius: 50px;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .morph-button:hover {
          border-radius: 12px;
          transform: scale(1.1) rotate(3deg);
        }

        /* Particle Button */
        .particle-button {
          background: #764ba2;
          position: relative;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .particles {
          position: absolute;
          top: 50%;
          left: 50%;
          width: 0;
          height: 0;
          pointer-events: none;
        }

        .particle {
          position: absolute;
          width: 4px;
          height: 4px;
          background: #ffffff;
          border-radius: 50%;
        }

        /* 3D Flip Button */
        .flip-button {
          background: transparent;
          transform-style: preserve-3d;
          perspective: 1000px;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .flip-front,
        .flip-back {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
          backface-visibility: hidden;
          border-radius: 12px;
          padding: 1rem 2rem;
        }

        .flip-front {
          background: #667eea;
          position: relative;
        }

        .flip-back {
          background: #764ba2;
          transform: rotateY(180deg);
        }

        .flip-button:hover {
          transform: rotateY(180deg);
        }

        /* Wave Button */
        .wave-button {
          background: #1a1a2e;
          border: 2px solid #667eea;
          position: relative;
          overflow: hidden;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .wave {
          position: absolute;
          top: 50%;
          left: -100%;
          width: 100%;
          height: 200%;
          background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.4), transparent);
          transform: translateY(-50%) rotate(45deg);
        }

        /* Circuit Button */
        .circuit-button {
          background: #0a0a0f;
          border: 2px solid #00ff88;
          position: relative;
          overflow: hidden;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
        }

        .circuit-svg {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
        }

        .circuit-path {
          fill: none;
          stroke: #00ff88;
          stroke-width: 2;
          stroke-dasharray: 200;
          stroke-dashoffset: 200;
        }

        .circuit-button:hover {
          background: rgba(0, 255, 136, 0.1);
          box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        /* Animated Border Button */
        .animated-border-button {
          position: relative;
          background: transparent;
          color: #fff;
          border: none;
          padding: 0.85rem 1.8rem;
          border-radius: 1.1rem;
          font-size: 1.1rem;
          font-family: inherit;
          cursor: pointer;
          z-index: 1;
          overflow: hidden;
          transition: color 0.18s, transform 0.12s;
        }
        .animated-border-button::before {
          content: "";
          position: absolute;
          inset: 0;
          border-radius: 1.1rem;
          padding: 2px;
          background: linear-gradient(90deg, #00ffe7, #00ff0a, #ffe600, #00ffe7);
          background-size: 300% 300%;
          background-position: var(--background-position, 0% 50%);
          -webkit-mask:
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
          -webkit-mask-composite: xor;
          mask-composite: exclude;
          pointer-events: none;
          z-index: 1;
          transition: filter 0.18s, background 0.18s;
        }
        .animated-border-button:hover {
          color: #00ffe7;
        }
        .animated-border-button:hover::before {
          filter: brightness(1.25) saturate(1.2);
        }
        .animated-border-button:focus-visible {
          outline: 2px solid #00ffe7;
          outline-offset: 2px;
        }
        .animated-border-button:active {
          transform: scale(0.97);
        }
        .animated-border-button:active::before {
          filter: brightness(0.85) saturate(0.9);
        }

        @media (max-width: 768px) {
          .main-grid {
            grid-template-columns: 1fr;
            gap: 2rem;
            padding: 0 0.5rem;
          }

          .control-panel {
            position: relative;
            top: 0;
            padding: 2rem;
            border-radius: 20px;
          }

          .title {
            font-size: clamp(2rem, 8vw, 3rem);
          }

          .subtitle {
            font-size: 1.125rem;
            padding: 0 1rem;
          }

          .stats-container {
            gap: 2rem;
            margin-top: 2rem;
          }

          .stat-number {
            font-size: 2rem;
          }

          .buttons-grid {
            grid-template-columns: 1fr;
            gap: 1.5rem;
            padding: 0.5rem;
          }

          .button-card {
            padding: 2rem;
          }

          .button-preview {
            height: 120px;
          }

          .control-title {
            font-size: 1.5rem;
            margin-bottom: 2rem;
          }
        }

        @media (max-width: 480px) {
          .container {
            padding: 1rem;
          }

          .header {
            margin-bottom: 3rem;
          }

          .button-card {
            padding: 1.5rem;
          }

          .control-panel {
            padding: 1.5rem;
          }
        }

        /* Loading animation */
        .fadeInUp {
          animation: fadeInUp 0.8s ease-out;
        }

        .button-card {
          animation: slideInCard 0.6s ease-out backwards;
        }

        .button-card:nth-child(1) { animation-delay: 0.1s; }
        .button-card:nth-child(2) { animation-delay: 0.2s; }
        .button-card:nth-child(3) { animation-delay: 0.3s; }
        .button-card:nth-child(4) { animation-delay: 0.4s; }
        .button-card:nth-child(5) { animation-delay: 0.5s; }
        .button-card:nth-child(6) { animation-delay: 0.6s; }
        .button-card:nth-child(7) { animation-delay: 0.7s; }
        .button-card:nth-child(8) { animation-delay: 0.8s; }
        .button-card:nth-child(9) { animation-delay: 0.9s; }
        .button-card:nth-child(10) { animation-delay: 1s; }
        .button-card:nth-child(11) { animation-delay: 1.1s; }
        .button-card:nth-child(12) { animation-delay: 1.2s; }

        @keyframes fadeInUp {
          0% {
            opacity: 0;
            transform: translateY(30px);
          }
          100% {
            opacity: 1;
            transform: translateY(0);
          }
        }

        @keyframes slideInCard {
          0% {
            opacity: 0;
            transform: translateY(50px) scale(0.95);
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
        }

        /* Enhanced accessibility */
        @media (prefers-reduced-motion: reduce) {
          *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
          }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
          .control-panel,
          .button-card {
            border-width: 2px;
            border-color: rgba(255, 255, 255, 0.3);
          }
          
          .button-name,
          .control-title {
            color: #ffffff;
          }
        }

        html, body, .container, .main-grid, .buttons-grid, .dropdown {
          scrollbar-width: thin;
          scrollbar-color: #764ba2 #181825;
        }

        ::-webkit-scrollbar {
          width: 10px;
          background: #181825;
        }
        ::-webkit-scrollbar-thumb {
          background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
          border-radius: 8px;
          min-height: 40px;
          border: 2px solid #181825;
        }
        ::-webkit-scrollbar-thumb:hover {
          background: linear-gradient(135deg, #a855f7 0%, #667eea 100%);
        }
        ::-webkit-scrollbar-track {
          background: #181825;
          border-radius: 8px;
        }
      `}</style>

      <div className="header">
        <h1 className="title">Button Micro-Interactions Lab</h1>
        <p className="subtitle">Explore and customize advanced button animations with real-time controls</p>

        <div className="stats-container">
          <div className="stat-item">
            <div className="stat-number">12</div>
            <div className="stat-label">Unique Animations</div>
          </div>
          <div className="stat-item">
            <div className="stat-number">7</div>
            <div className="stat-label">Easing Functions</div>
          </div>
          <div className="stat-item">
            <div className="stat-number">∞</div>
            <div className="stat-label">Possibilities</div>
          </div>
        </div>
      </div>

      <div className="main-grid">
        <div className="control-panel">
          <h2 className="control-title">Animation Controls</h2>
          
          <div className="control-group">
            <label className="control-label">Animation Speed</label>
            <div className="slider-container">
              <input
                type="range"
                className="slider"
                min="0.1"
                max="3"
                step="0.1"
                value={settings.speed}
                onChange={(e) => setSettings({ ...settings, speed: Number.parseFloat(e.target.value) })}
              />
              <span className="slider-value">{settings.speed}x</span>
            </div>
          </div>

          <div className="control-group">
            <label className="control-label">Easing Function</label>
            <div className="select-container">
              <div ref={selectRef} className={`select ${isDropdownOpen ? "open" : ""}`} onClick={toggleDropdown}>
                {easingOptions.find((option) => option.value === settings.easing)?.label || "Select Easing"}
              </div>
              {isDropdownOpen && (
                <div className={`dropdown position-${dropdownPosition}`} ref={dropdownRef}>
                  {easingOptions.map((option) => (
                    <div
                      key={option.value}
                      className={`dropdown-item ${option.value === settings.easing ? "selected" : ""}`}
                      onClick={() => {
                        setSettings({ ...settings, easing: option.value })
                        setIsDropdownOpen(false)
                      }}
                    >
                  {option.label}
                    </div>
              ))}
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="buttons-grid">
          {buttons.map((button) => {
            const ButtonComponent = button.component
            const animationState = animationStates[button.id] || initializeAnimationState(button.id)
            const duration = getAnimationDuration(button.id)
            const currentTime = (animationState.progress / 100) * duration

            return (
              <div
                key={button.id}
                className="button-card"
                onMouseMove={(e) => {
                  const rect = e.currentTarget.getBoundingClientRect()
                  const x = ((e.clientX - rect.left) / rect.width) * 100
                  const y = ((e.clientY - rect.top) / rect.height) * 100
                  e.currentTarget.style.setProperty("--mouse-x", `${x}%`)
                  e.currentTarget.style.setProperty("--mouse-y", `${y}%`)
                }}
              >
                <h3 className="button-name">{button.name}</h3>
                <div className="button-preview">
                  <ButtonComponent settings={settings} animationState={animationState} />
                </div>
                <div className="timeline">
                  <div className="timeline-header">
                    <span className="timeline-label">Animation Timeline</span>
                    <div className="timeline-info">
                      <span>Duration: {duration.toFixed(1)}s</span>
                      <span>Speed: {settings.speed}x</span>
                      <span>
                        State: {animationState.isPlaying ? "playing" : animationState.isPaused ? "paused" : "stopped"}
                      </span>
                    </div>
                  </div>

                  <div className="timeline-controls">
                    <button
                      className={`timeline-btn ${animationState.isPlaying ? "active" : ""}`}
                      onClick={() => playAnimation(button.id)}
                    >
                      ▶ Play
                    </button>
                    <button className="timeline-btn" onClick={() => pauseAnimation(button.id)}>
                      ⏸ Pause
                    </button>
                    <button className="timeline-btn" onClick={() => stopAnimation(button.id)}>
                      ⏹ Restart
                    </button>
                  </div>

                  <div
                    className="timeline-track"
                    onClick={(e) => {
                      const rect = e.currentTarget.getBoundingClientRect()
                      const x = e.clientX - rect.left
                      const progress = (x / rect.width) * 100
                      scrubAnimation(button.id, Math.max(0, Math.min(100, progress)))
                    }}
                >
                  <div
                    className="timeline-bar"
                    style={{
                        width: `${animationState.progress}%`,
                    }}
                  />
                </div>

                  <div className="timeline-details">
                    <div className="timeline-time">
                      {currentTime.toFixed(1)}s / {duration.toFixed(1)}s
              </div>
                    <div>Progress: {animationState.progress.toFixed(1)}%</div>
                  </div>

                  <div className="timeline-phases">
                    {Array.from({ length: 4 }, (_, i) => (
                      <div
                        key={i}
                        className={`timeline-phase ${
                          animationState.progress > (i + 1) * 25
                            ? "completed"
                            : animationState.progress > i * 25 && animationState.progress <= (i + 1) * 25
                              ? "active"
                              : ""
                        }`}
                      />
                    ))}
                  </div>
                </div>
              </div>
            )
          })}
        </div>
      </div>
    </div>
  )
}
